## Q3 (a)

```asm
INCLUDE Irvine32.inc

.data
    arr DWORD 10,25,100,35,30,85,90,84,72,60
.code
main PROC
    mov esi,OFFSET arr
    mov eax,0
    call MAXIMUM
    call WriteDec
    exit
main ENDP

MAXIMUM PROC
    mov ecx,LENGTHOF arr
    mov ebx,0
L1:
    cmp [esi+ebx],eax
    JLE next
    mov eax,[esi+ebx]
    add ebx,4
    loop L1
next:
    add ebx,4
    loop L1

    ret
MAXIMUM ENDP
END main
```

## Q3 (b)
```asm
INCLUDE Irvine32.inc
.data
    arr BYTE "FAST National University, Karachi",0
    CCase BYTE 30 DUP(0)  
.code
    CAPITALCASE PROTO, array:PTR BYTE  
main PROC
    mov esi,0
    INVOKE CAPITALCASE, ADDR arr
    CALL SHOW
    exit
main ENDP
CAPITALCASE PROC, array:PTR BYTE
    mov edx, array  
L1:
    mov al, [edx]  
    cmp al, 0              
    je quit
    cmp al, 'A'            
    jl next
    cmp al, 'Z'            
    jg next
    mov CCase[esi], al     
    inc esi                
next:
    inc edx             
    jmp L1
quit:
    mov CCase[esi], 0  
    ret
CAPITALCASE ENDP
SHOW PROC
    mov edx, OFFSET CCase
    call WriteString
    ret
SHOW ENDP
END main
```

## Q3 (c)

```asm
TITLE Search
INCLUDE Irvine32.inc
.data
    arr BYTE "UUUUReadingUUUAssemblyUUUUULanguage",0
.code
    STRING PROTO array:PTR BYTE
main PROC
    INVOKE STRING, ADDR arr
    mov edx, OFFSET arr
    call WriteString
    exit
main ENDP

STRING PROC, array:PTR BYTE
    mov edx, array
    
L1:
    mov al, [edx]      ; Get current character
    cmp al, 0          ; Check for end of string
    je quit            ; If end of string, quit
    cmp al, 'U'        ; Compare with 'U'
    jne skip           ; If not 'U', skip replacement
    cmp al,[edx+1]
    jne skip
    mov BYTE PTR [edx], 7h ; Replace 'U' with 0
skip:
    inc edx            ; Move to next character
    jmp L1             ; Continue loop
    
quit:
    ret
STRING ENDP
END main
```

## Q4 (b)

```asm
TITLE Calculate ones in binary
INCLUDE Irvine32.inc
.data
    val DWORD 27
.code
main PROC
    mov eax,val
    mov ebx,0
    mov ecx,32
L1:
    shr eax,1
    JC one
    loop L1
    jmp quit
one:
    inc ebx
    loop L1
quit:
    mov eax,ebx
    call WriteDec
exit
main ENDP
END main
```

## Q4 (b)

```asm
INCLUDE Irvine32.inc
.data
    arr DWORD 0,2,5,9,10
.code
main PROC
    mov esi,0
    mov edx,0
    mov ecx,(LENGTHOF arr) - 1
L1:
    mov eax,arr[esi]
    mov ebx,arr[esi+4]
    sub ebx,eax
    add edx,ebx
    add esi,4
    loop L1
    mov eax,edx
    call WriteDec
exit
main ENDP
END main
```

## Q6 (a)

```asm
TITLE Search
INCLUDE Irvine32.inc
.data
    Array1 DWORD 12,8,30,105,200
    Array2 DWORD 5,7,9,12,15,18,25,36,30,0,35,105,182,176,195,102,140,10,19,200
    found BYTE "Element Found!",0
    notFound BYTE "Element not found!",0

.code
main PROC
    mov esi,0
    mov edi,OFFSET Array2
    mov ecx,LENGTHOF Array1
L1:
    push ecx
    mov edi,OFFSET Array2
    mov ecx,LENGTHOF Array2
    mov eax, Array1[esi]
    REPNE SCASD
    jne next
    mov edx,OFFSET found
    call WriteString
    call WriteInt
    call Crlf
    add esi,4
    pop ecx
    loop L1
    jmp quit
next:
    mov edx,OFFSET notFound
    call WriteString
    call WriteInt
    call Crlf
    add esi,4
    pop ecx
    loop L1
quit:
    exit
main ENDP
END main
```

## Q6 (d)

```asm
INCLUDE Irvine32.inc
.data
    ewords DWORD 1,2,3,4,5,6,7,8,9,10
.code
main PROC
    mov esi,OFFSET ewords
    mov edi,OFFSET ewords
    mov ecx,LENGTHOF ewords
L1:
    lodsd
    mul eax
    stosd
    loop L1

    mov ecx,LENGTHOF ewords
    mov esi,0
L2:
    mov eax,ewords[esi]
    call WriteDec
    call Crlf
    add esi,4
    loop L2
exit
main ENDP
END main
```
